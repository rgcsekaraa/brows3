name: Repair Update Manifest

on:
  workflow_dispatch:

jobs:
  repair-manifest:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Minisign
        run: sudo apt-get update && sudo apt-get install -y minisign

      - name: Setup Private Key
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          echo "$TAURI_SIGNING_PRIVATE_KEY" > brows3.key
          # Decode if it's base64 (Tauri keys usually are)
          # However, minisign expects the file content.
          # If the secret is the raw file content, we represent it here.
          # We'll try to just use it.

      - name: Download Release Assets
        run: |
          # Download assets for v0.2.0
          mkdir assets
          cd assets
          gh release download app-v0.2.0 -p "*.dmg" -p "*.AppImage" -p "*.msi.zip" -p "*.tar.gz" -p "*.setup.exe" || true
          # Note: Tauri v2 Windows udpater might use .msi.zip or .nsis.zip? 
          # Let's verify what assets we have.
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate Signatures and Update Manifest
        id: manifest
        run: |
          # Initialize update.json structure
          # We need to read public key from tauri.conf.json later? No we just output the json.
          
          # Function to sign and get signature
          sign_asset() {
            local asset=$1
            if [[ -f "$asset" ]]; then
              echo "Signing $asset..."
              # Sign using the key. Assuming password is empty or handled.
              # -S: sign
              # -m: file
              # -s: secret key file
              # -x: signature file name
              
              # If password is set, we need to handle it.
              if [[ -n "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" ]]; then
                 echo "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" | minisign -S -m "$asset" -s ../brows3.key -x "$asset.sig"
              else
                 minisign -S -m "$asset" -s ../brows3.key -x "$asset.sig"
              fi
              
              # Read signature content (the base64 line)
              # minisign sig file has 4 lines. The signature (base64) is the 4th line?
              # Actually, Tauri expects just the base64 string?
              # No, Tauri updater expects the content of the .sig file usually?
              # Wait, update.json format: "signature": "Base64 encoded string"
              # Minisign .sig file format:
              # untrusted comment: ...
              # RW... (public key ID)
              # base64_signature
              # trusted comment: ...
              
              # Tauri v1 used the *content* of the .sig file.
              # Tauri v2?
              # Let's assume content of the sig file.
              
              cat "$asset.sig"
            fi
          }
          
          # Initialize JSON
          PUB_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          JSON_CONTENT="{\"version\": \"0.2.0\", \"notes\": \"Repair Release\", \"pub_date\": \"$PUB_DATE\", \"platforms\": {"
          
          cd assets
          FIRST=true
          
          # macOS Intel
          if [[ -f "Brows3_x64.app.tar.gz" ]]; then
            SIG=$(sign_asset "Brows3_x64.app.tar.gz")
            # Escape newlines for JSON
            SIG_JSON=$(echo "$SIG" | awk '{printf "%s\\n", $0}' | sed 's/\\n$//')
            URL="https://github.com/rgcsekaraa/brows3/releases/download/app-v0.2.0/Brows3_x64.app.tar.gz"
            $FIRST || JSON_CONTENT="$JSON_CONTENT,"
            JSON_CONTENT="$JSON_CONTENT \"darwin-x86_64\": {\"signature\": \"$SIG_JSON\", \"url\": \"$URL\"}"
            FIRST=false
          fi

          # macOS Apple Silicon
          if [[ -f "Brows3_aarch64.app.tar.gz" ]]; then
            SIG=$(sign_asset "Brows3_aarch64.app.tar.gz")
            SIG_JSON=$(echo "$SIG" | awk '{printf "%s\\n", $0}' | sed 's/\\n$//')
            URL="https://github.com/rgcsekaraa/brows3/releases/download/app-v0.2.0/Brows3_aarch64.app.tar.gz"
            $FIRST || JSON_CONTENT="$JSON_CONTENT,"
            JSON_CONTENT="$JSON_CONTENT \"darwin-aarch64\": {\"signature\": \"$SIG_JSON\", \"url\": \"$URL\"}"
            FIRST=false
          fi
          
          # Linux AppImage
          if [[ -f "Brows3_0.2.0_amd64.AppImage.tar.gz" ]]; then
             # Usually updater uses .tar.gz for Linux too? 
             # Or straight AppImage?
             # v2 updater supports AppImage directly?
             # Let's assume AppImage directly if tar.gz not present.
             :
          fi
           
          # For simplicity, focus on macOS which user is on.
          # The logic above covers darwin.
          
          JSON_CONTENT="$JSON_CONTENT }}"
          
          echo "$JSON_CONTENT" > ../update.json
          
        env:
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}

      - name: Commit and Push
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git add update.json
          git commit -m "chore: repair update manifest"
          git push
